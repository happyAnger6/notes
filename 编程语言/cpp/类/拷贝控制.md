# 拷贝控制

## 对象移动

+ 有些移动是不必要的
+ IO类或unique_ptr这样的类,包含不能被共享的资源
+ 在旧标准的标准库中,容器保存的类必须是可拷贝的,在新标准中,我们可以使用容器保存不可拷贝的类型,只要它们能被移动即可

#### 标准库容器,string,shared_ptr既支持移动也支持拷贝. IO类和unique_ptr类可以移动但不能拷贝

### 右值引用

必须绑定到右值的引用,右值引用有一个重要的性质--只能绑定到一个将要销毁的对象.因此,我们可以自由地将一个右值引用资源"移动"到另一个对象中.

+ 可以将一个const引用绑定到一个右值上

```cpp
const int &r3 = i *42;
```

+ 返回左值引用的函数,连同赋值、下标、解引用和前置递增/递减运算符,都是返回左值的表达式的例子.我们可以将一个左值引用绑定到这类表达式的结果上
+ 返回非引用类型的函数,连同算术、关系、位以及后置递增/递减运算符,都生成右值.我们不能将一个左值引用绑定到这类表达式上,但我们可以将一个const的左值引用或一个右值引用绑定到这类表达式上

#### 左值持久,右值短暂

左值有持久的状态,右值要么是字面值常量,要么是在表达式求值过程中创建的临时对象

+ 所引用的对象即将销毁
+ 该对象没有其它用户

##### 使用右值对象的代码能够自由地接管所引用的对象的资源

#### 变量是左值,我们不能将一个右值引用绑定到一个右值引用类型的变量上

#### 标准库move函数

+ utility头文件
+ 调用move意味着,我们希望像一个右值一样来处理它,除了对其赋值或销毁外,我们将不再使用它.

##### 我们可以销毁一个移动后的源对象,也可以赋予它新值,但不能使用一个移动后源对象的值

+ 我们直接使用std::move,而不使用using声明

### 移动构造和移动赋值运算符

### 移动操作、标准库容器和异常

#### noexcept

+ 移动操作抛出异常是允许的
+ 标准库容器能对异常发生时其自身的行为提供保障
+ 移动一个对象通常会改变它的值,在此情况下,vector将不能满足自身保持不变的要求
+ 如果vector使用了拷贝构造函数且发生了异常,它可以很容易地满足要求.

#### 移动赋值运算符

```cpp
x& x::operator=(x &&rhs) noexcept
{
    if (this != &rhs) //检测自赋值. 我们检测的原因是此右值可能是move调用的返回结果.
    ...

    return *this;
}
```

#### 移动后源对象必须可析构

+ 在移动操作之后,移后源对象必须保持有效的、可析构的状态,但是用户不能对其值进行任何假设.

#### 合成的移动操作

+ 与拷贝操作不同,编译器根本不会为某些类合成移动操作
+ 只有当一个类没有定义任何自己版本的拷贝控制成员,且类的每个非static成员数据成员都可移动时,才会为其合成移动构造函数或移动赋值运算符
+ 如果一个成员是类类型,且该类有对应的移动操作,编译器也能移动这个成员

##### 与拷贝操作不同,移动操作永远不会隐式定义为删除的函数.

+ 如果我们显式地要求编译器生成=default的移动操作,且编译器不能移动所有成员,则编译器会将移动操作定义为删除的函数.









