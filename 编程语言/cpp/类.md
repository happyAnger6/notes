# 类

## 1.定义抽象数据类型

### 1.1 Sales_data类
```cpp
struct Sales_data {
    string isbn() const { return bookNo; }
    Sales_data& combine(const Sales_data&);
    double avg_price() const;

    string bookNo;
    unsigned uints_sold = 0;
    double revenue = 0.0;
};

//非成员函数接口
...
```

#### 1.1.1 定义在类内部的函数是隐式inline的
#### 1.1.2 定义成员函数
所有成员函数声明都必须在类内,但是成员函数定义可以在类内也可以在类外

#### 1.1.3 引入this
##### this是一个常量指针

#### 1.1.4 引入const成员函数
##### 常量对象,常量对象的引用或指针只能调用常量成员函数

#### 1.1.5 类作用域和成员函数
##### 即使变量定义在函数之后,函数中也是能够使用变量.
###### 编译器分两步处理类:先编译成员声明,然后才轮到成员函数体.

#### 1.1.6 在类的外部定义成员函数

#### 1.1.7 定义一个返回this对象的函数
```cpp
return *this;
```
##### 当我们定义的函数类似于某个内置运算符时,应该让函数的行为尽量模仿这个运算符.

#### 1.1.8 定义类相关的非成员函数
##### IO类属于不能被拷贝的类
##### 执行输出任务的函数应尽量减少对格式的控制

### 2.构造函数
构造函数的任务是创建对象的时候初始化类对象的数据成员.

+ 构造函数和类名相同,没有返回值
+ 构造函数不能声明为const

#### 2.1 合成的默认构造函数

+ 如果存在类内初始值,用它来初始化成员
+ 否则,默认初始化该成员

##### 某些类不能依赖合成的默认构造函数

+ 只有当类没有任何构造函数时,编译器才会自动生成默认构造函数
+ 如果类内包含有内置类型或复合类型成员,只有当这些成员全都赋予了类内初始值时,这个类才适合于使用合成的默认构造函数
+ 如果类中包含一个其他类类型的成员,且它没有默认构造函数,则编译器不能为其合成默认构造函数

#### 2.2 定义Sales_data构造函数

```cpp
struct Sales_data {
    Sales_data() = default;
    Sales_data(const string &s) : bookNo(s) {}
    string bookNo;
};
```

##### =default的含义
+ 我们希望这个函数的作用完全等同于之前使用的合成默认构造函数
+ =default既可以在类内部(内联的),也可以在类外部

#### 构造函数初始值列表
+ 当某个类成员被构造函数初始值列表忽略时使用隐式初始化

#### 拷贝、赋值和析构

##### 拷贝的时机:  
+ 初始化变量
+ 以值方式传递函数参数或返回一个对象

#### 某些类不能依赖于合成的版本
+ 类需要分配类对象之外的资源时,管理动态内存的类通常不能依赖于上述操作的合成版本
+ 使用vector和string的类能避免分配和释放内存带来的复杂性

### 6. 类的静态成员

#### 声明静态成员
+ 类的静态成员存在于任何对象之外
+ 类的静态成员函数不包含this指针

#### 使用类的静态成员
+ 使用作用域运算符直接访问
+ 使用类的对象、引用或指针来访问
+ 成员函数不用使用作用域运算符直接使用

#### 定义并初始化一个静态成员
+ 从类名开始,静态成员的定义就位于类的作用域之内了,我们也能用私有函数来初始化静态成员

#### 静态成员的类内初始化
+ 可以为静态成员提供const整数类型的类内初始值,不过要求静态成员必须是字面值常量类型的constexpr.

```cpp
class Account {
private:
    static constexpr int period = 30;
};
```
##### 如果在类内部定义了一个初始值,则成员的定义不能再指定一个初始值了
##### 即使一个常量静态成员在类内部被初始化了,通常也应该在类外部定义一个该成员

#### 静态成员能用于某些场景,而普通成员不能
+ 静态数据成员的类型可以是它所属的类类型
+ 静态成员可以作为默认实参

