# 继承

## 定义基类和派生类

#### 基类负责定义在层次关系中所有类共同拥有的成员,而每个派生类定义各自特有的成员.

#### 虚函数

+ 基类希望它的派生类各自定义适合自身的版本
+ public继承表明我们可以完全把派生类当成基类来使用
+ 派生类必须在其内部对所有重新定义的虚函数进行声明,在派生类中virtual不是必须的
+ c++11允许派生类显示地注明将使用哪个成员函数改写基类的虚函数,通过override

#### 动态绑定

+ 使用基类引用或指针调用一个虚函数时将发生动态绑定

### 定义基类

```cpp
class Quote{
public:
    Quote() = default;
    Quote(const string &book, double price):
                book_no(book), price(price) {}
    std::string isbn() const { return book; }
    virtual double net_price(size_t n) const
            { return n * price; }
    virtual ~Quote() = default; // 对析构函数进行动态绑定
private:
    string book;
protected:
    double price;
};
```
+ 基类通常都应该定义一个虚析构函数,即使该函数不执行任何实际操作也是如此.

#### 成员函数与继承

+ 成员函数如果没有被声明为虚函数,则其解析过程发生在编译时而非运行时.

#### 访问控制与继承

+ 派生类可以继承定义在基类中的成员,但派生类不一定有权访问从基类继承而来的成员
+ 和其他使用基类的代码一样,派生类能访问公有成员,而不能访问私有成员
+ 受保护成员派生类在权访问,同时禁止其他用户访问

### 定义派生类

+ 派生类必须将其继承而来的成员函数需要覆盖的那些重新声明
+ 派生列表中的访问说明符用来控制从基类继承而来的成员是否对派生类用户可见
+ 如果一个派生是公有的,则基类的公有成员也是派生类接口的组成部分
+ 能将公有派生的对象绑定到基类的指针或引用上
+ 因为是公有继承,因此在任何使用基类的引用或指针的地方都能使用派生类

#### 派生类对象及派生类向基类的类型转换

+ 编译器会隐式地执行派生类到基类的转换
+ 在派生类对象中含有与其基类对应的组成部分,这一事实是继承的关键所在

#### 派生类构造函数

+ 派生类必须使用基类的构造函数来初始化它的基类部分
+ 首先初始化基类部分,然后按照声明顺序依次初始化派生类的成员

#### 派生类使用基类成员

+ 派生类可以访问基类的公有成员和受保护成员
+ 派生类的作用域嵌套在基类的作用域之内.因此对于一个派生类说,使用派生类成员与使用基类成员的方式没有什么不同

#### 继承与静态成员

+ 在整个继承体系中只存在静态成员的唯一定义
+ 静态成员遵循通用的访问控制规则

#### 派生类的声明

+ 派生类的声明与其他类差别不大
+ 被用作基类的类必须定义而非仅仅声明
+ 对于一个最终的派生类来说,它会继承其直接基类的成员;该直接基类的成员又含有其基类成员;依此类推直至继承链顶端.

#### 防止继承的发生

+ c++11提供了final关键字防止继承的发生

```cpp
class NoDerived final {};

class Base{};
class Last final : Base {};
```

### 类型转换与继承

##### 理解基类和派生类之间的类型转换是理解C++语言面向对象编程的关键所在

+ 当使用基类引用或指针时,实际上我们并不清楚该引用或指针所绑定的真实类型

#### 静态类型与动态类型

+ 如果表达式既不是指针也不是引用,那么它的动态类型与静态类型一致

#### 不存在基类向派生类的隐式类型转换

#### 在对象之间不存在类型转换

+ 将一个派生类对象赋值给一个基类对象,则实际上运行的赋值运算符也是基类中定义的那个
+ 当我们用一个派生类对象为一个基类对象初始化或赋值时,只有该派生类对象中的基类部分会被拷贝、移动或赋值,它的派生类部分会被忽略掉

## 虚函数

#### 所有的虚函数都必须有定义

#### 对虚函数的调用可能在运行时才解析

### c++的多态性

+ 引用或指针的静态类型与动态类型不同这一事实正是C++语言支持多态的根本所在
+ 运行时决定的依据是指针或引用所绑定的对象的真实类型
+ 非虚函数和通过对象进行的函数调用也在编译时绑定

### 派生类中的虚函数

+ 虚函数在所有派生类中仍然是虚函数
+ 派生类中的虚函数形参类型必须与基类一致
+ 返回类也必须一致,有一个例外,基类B的返回类型为B*,派生类D的返回类型为D*,要求从D到B的类型转换是可访问的

### final和override说明符

+ 使用了override而没有覆盖基类中的虚函数将会报告编译错误
+ 声明为final的函数不能覆盖, final函数只能用于虚函数

### 虚函数与默认实参

+ 如果某次函数调用使用了默认实参,则该实参值由本次调用的静态类型决定
+ 通过基类引用或指针调用虚函数,则使用基类定义的默认实参

### 回避虚函数机制

```cpp
baseP->Quote::net_price(42)
```

#### 通常情况下,只有成员函数(或友元)中的代码才需要使用作用域运算符来回避虚函数机制

+ 如果一个派生类虚函数调用它的基类版本而没有使用作用域运算符,则会解析为对自身的调用导致无限循环

## 抽象基类

### 书写=0就可以将一个虚函数说明为纯虚函数, =0只能出现在类内部的虚函数声明处

### 可以为纯虚函数提供定义,但是必须在类的外部

### 含有纯虚函数的类是抽象基类,不能定义其对象

### 派生类构造函数只初始化它的直接基类

## 访问控制与继承

### 受保护的成员

+ 和私有成员类似,受保护的成员对于类用户来说是不可访问的
+ 和公有成员类似,受保护的成员对于派生类成员和友元是可访问的
+ 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员.

### 公有、私有和受保护继承

+ 派生访问说明符的目的是控制派生类用户(包括派生类的派生类在内)对于基类成员的访问权限
+ 如果继承是公有的,成员将遵循原有的访问说明符否则将遵循继承访问说明符
+ 受保护继承基类中的所有公有成员在派生类中是受保护的

### 派生类向基类转换的可访问性

假定D继承自B
+ 只有当D公有继承B时,用户代码才能使用派生类向基类的转换
+ 不论D以什么方式继承B,D的成员函数和友元都能使用派生类向基类的转换;派生类向直接基类的转换对于派生类成员和友元来说永远是可访问的
+ 如果D继承B的方式是公有的或受保护的，则D的派生类成员和友元可以使用D向B的转换,如果是私有的则不可以

#### 对于代码的某个节点来说,如果基类的公有成员是可访问的,则可以执行向基类的转换,反之则不行.





