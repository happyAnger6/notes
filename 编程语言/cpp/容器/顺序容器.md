# 顺序容器

为程序员提供了控制元素存储和访问顺序的能力

## 概述

+ 向容器中添加或删除元素的代价
+ 非顺序访问容器的代价

### 对比

+ string, vector将元素保存在连续的内存空间,随机访问快.
+ list, forward_list任何位置插入删除都很快,不支持随机访问
+ deque两端添加或删除元素很快
+ forward_list设计目标是达到与手写链表相同的性能,因此没有size()操作
+ 对于其他容器而言,size保证是一个常量操作
+ 现代c++程序应该使用标准容器而不是原始数据结构


#### 应用中占主导地位的操作决定了容器的类型(访问操作还是插入/删除操作更多)

### 概览

+ 某些操作是所有容器类型都提供的
+ 顺序容器构造函数的一个版本接受容器大小参数,它使用了元素类型的默认构造函数.但某些类型没有默认构造函数,因此必须传递一个初始化器

```cpp
vector<noDefault> v1(10, init); // right.
vector<noDefault> v1(10); // wrong.
```

## 迭代器

+ foward_list迭代器不支持自减运算符

### 迭代器范围

+ 迭代器范围的概念是标准库的基础
+ [begin, end)

## 列表初始化

## 与顺序容器大小相关的构造函数

+ 如果元素是内置类型或具有默认构造函数则可以只指定大小
+ 只有顺序容器的构造函数才接受大小参数,关联容器并不支持

## array具有固定大小

+ 大小也是array类型的一部分
+ array能够进行拷贝和赋值操作,初始值类型必须与要创建的类型一致,因为大小也是类型一部分

## 赋值和swap

```cpp
c1 = c2;
c1 = {a, b, c};
```

### swap通常比拷贝赋值快得多

### assign不适用于关联容器和array

+ assign可以从不同但相容的类型赋值,或者从容器的一个子序列赋值
+ swap只是交换了两个容器的内部数据结构,swap不对任何元素进行拷贝、删除或插入操作,因此可以保证在常数时间内完成
+ 与其他容器不同,swap array会真正交换两个容器中的元素,因此交换时间与array中元素数目成正比
+ 统一使用非成员版本的swap是一个泛型编程的好习惯

## 容器大小操作

+ forward_list不支持size

## 关系运算符

+ 比较容器实际上是对容器中的元素进行逐元素比较
+ 容器的关系运算符使用元素的关系运算符完成

## 顺序容器操作

+ 这些操作会改变容器大小,因此array不支持
+ forward_list不支持push_back, emplace_back
+ forward_list有自己专有的insert, emplace

### 向vector, string, deque插入元素会使所有指向容器的迭代器、引用和指针失效

### 容器元素是拷贝

#### 使用push_front

### 在容器的特定位置添加元素

+ insert没有限制不能在vector首插入元素,这种操作可能很耗时

### 插入范围内元素

+ 接受一个元素数目和一个值
+ 接受一对迭代器
+ 授受初始化列表

### 访问元素

+ 包括array在内的每个顺序容器都有一个front成员函数
+ 而forward_list之外的所有顺序容器都有一个back成员函数
+ 在调用front, back之前要确保容器非空,否则行为是未定义的

#### 访问成员函数返回的是引用

+ 如果容器是const,则返回值是const的引用
+ 如果我们使用auto来保存函数的返回值,如果要改变元素的值,需要将变量定义为引用类型

#### 下标操作和安全的随机访问

### 删除元素

+ pop_back()
+ pop_front()
+ erase(p)
+ erase(b, e)
+ clear

## 额外的string操作


