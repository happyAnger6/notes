# 协程漫谈

## 协程的诞生背景

### C10K问题

#### 单机服务器如何同时处理10k个客户连接
[C10k wiki](https://en.wikipedia.org/wiki/C10k_problem)

传统的服务器实现(如apache),通过多线程或多进程的方式处理多个连接,当连接达到一定数量时,线程或进程的内存开销及上下文切换开销都会
变得不可接受.因此要解决C10k问题,需要新的编程模式、操作系统实现、及配置的支持.  

##### 下文详细讲述了如何解决C10k问题:  
[C10K 解决方法](http://www.kegel.com/c10k.html)

通过上述文章我们可以get到几个关键点:

1. 通过I/O多路复用,如使用epoll来同时管理多个连接
2. 通过非阻塞I/O或异步IO(AIO,linux上实现还不好)避免阻塞

其中一个关键点就是使用异步方式编程,异步编程和同步编程相比,虽然提高了cpu使用率
##### 但是也带来了以下一些问题(nodeJS除外):

1. 我们需要自己管理底层的事件循环(如epoll)
2. 我们需要自己管理异步操作的创建、销毁
3. 我们需要自己管理异步操作的状态(经常需要将一个执行流程按照阻塞点拆分成不同的异步阶段)
4. 流程分散,代码不直观,不容易理解和阅读

## 更好的解决方式??

设想一下,如果我们可以创建大量的线程,并且线程的切换开销很小,那我们就可以在需要阻塞时创建线程同步处理即可  
这样代码编程模式还是同步方式,和我们通常的思维方式一致,但是确能得到传统异步编程模式同样的结果.  
##### 以同步的方式实现异步-----这就是协程的思想.

### 协程

#### 概念

要了解协程,我们先从它的概念入手.其实,**协程**的概念很早就出现了,可以看下[wiki百科](https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B)的解释:  

```doc
协程（英语：coroutine）是计算机程序的一类组件，推广了协作式多任务的子程序，允许执行被挂起与被恢复。
相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。
协程更适合于用来实现彼此熟悉的程序组件，如协作式多任务、异常处理、事件循环、迭代器、无限列表和管道。

根据高德纳的说法, 马尔文·康威于1958年发明了术语“coroutine”并用于构建汇编程序 ，关于协程最初的出版解说在1963年发表。
```

从wiki的解释可以看出,协程有两个关键点:  
1. 比子例程(可以理解为线程)更灵活
2. **协作**完成某项功能,允许挂起和恢复.

我们可以通过一个典型例子来理解协程:

###### 其中"yield"关键字表示让出执行权给另外一个协程.
```
var q := queue

coroutine producer
    loop
        while q not full
            q.add(product)
        yield consumer

coroutine consumer
    loop
        while q is not empty
            product = q.pop()
        yield producer
```

#### 实现

考虑实现协程,需要解决以下几个问题:
1. 轻量. 协程占用资源要少,这样才能支持大量的协程
2. 调度和管理. 如何调度和管理这么多的协程.


## 对比