# 锁

## 互斥锁

### 用原子操作和信号量实现互斥锁

```C

typedef struct {
    int val;
    sem_t *sem;
}mutex_lock_t;

mutex_lock(mutex_lock_t *lock)
{
    while(cas(&lock->val, 0, 1) != 0)
    {
        sem_wait(sem);
    }
}

mutex_unlock(mutex_lock_t *lock)
{
    atomic_dec(&lock->val, 1);
    sem_pos(sem);
}

```

## 读写锁

### 用原子操作和信号量实现读写锁

```C
typedef struct {
    int readers;
    int writers;
    sem_t *sem;
    mutex_lock_t *lock;
}mutex_rw_lock_t;

mutex_rlock(mutex_rw_lock_t *lock)
{
    mutex_lock(lock->lock);
    while (lock->writers != 0) {
        mutex_unlock(lock->lock):
        sem_wait(sem);
    }

    lock->readers++;
    mutex_unlock(lock->lock);
}

mutex_wlock(mutex_rw_lock_t *lock)
{
    mutex_lock(lock->lock);
    while (lock->readers != 0) {
        mutex_unlock(lock->lock):
        sem_wait(sem);
    }

    lock->writers++;
    mutex_unlock(lock->lock);
}

mutex_runlock(mutex_rw_lock_t *lock)
{
    mutex_lock(lock->lock);
    lock->readers--;
    if(lock->readers == 0)
        sem_post(sem);
    
    mutex_unlock(lock->lock);
}

mutex_wunlock(mutex_rw_lock_t *lock)
{
    mutex_lock(lock->lock);
    lock->writers--;
    sem_post(sem);
    mutex_unlock(lock->lock);
}

```