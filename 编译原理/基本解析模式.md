# 基本解析模式

## 1.从文法到递归下降识别器

### 目的
本模式能够根据语言的文法,生成能匹配语言中式子和语句的递归下降识别器　　
此模式与所有递归下降的词法解析器、语法解析器或者树解析器的核心框架相同

###　讨论
文法能够精确地描述待识别的语言,而且,它还是良好的文档资料

### 限制
这种模式能够处理大部分文法,但对有些文法却无能为力.如左递归文法.

```c
void r() { r(); match(X); }
```

除了左递归,还有一些文法现象会导致识别器带有不确定性.具有不确定性的识别器不知道该调用哪个.  

### 实现

```Java
public class G extends Parser { // Java语言定义的解析器
    <<词法单元类型的定义>>
    <<合适的构造函数>>
    <<规则对应的方法>>
}
```

#### Parser类里定义了解析器中都有的字段,比如向前看词法单元和输入流

### 规则的转换

下面会为文法中的每个规则r都建立一个同名方法:
```Java
public void r() {

}
```

### 词法单元的转换

+ 如果规则中出现类型T词法单元,则对应于调用方法match(T),   
+ match()是Parser类的辅助函数,  
+ 如果入参T能匹配当前的向前看词法单元,它就将指针前移,相当于消耗了这个词法单元.  
+ 如果不能匹配,就会抛出异常报错.

### 子规则的转换

可以根据向前看词法的复杂度的不同,使用switch或者if-else.  
每个子规则都有表达式,计算当前的输入是否匹配  

```Java
if (<<向前看到alt1>>) { match_alt1(); }
else if (<<向前看到alt2>>) { match_alt2(); }
...
else if (<<向前看到altN>>) { match_altN(); }
else <<抛出异常>>  //解析失败,没有合适的匹配
```

## 2.LL(1)递归下降的词法解析器

### 目的

识别字符流中的模式,生成词法单元流

### 讨论
每个词法单元都有2个重要的属性:词法类型(符号的类别)和相关联的内容(通常是字符串)

